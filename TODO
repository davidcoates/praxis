- Checking poly signatures

- Data

- Classes, instances

- XTypes

- Lenses, 'in' constraints

- Modules
- module imports should be side effect free. So top level terms should be pure. They should also be shareable.
- Polymorphic types shouldn't be affine?

- Abstract types

For the sake of simplicity, may want to avoid view operators.

This means we need to disginstuish between value and view patterns.

f = cases
  !Cons (x, xs) -> ...
  !Nil -> ...

But then we have duplication...
Perhaps default to value?

or separate construct

f = !cases
  Cons (x, xs) -> ...
  Nil -> ...


Restricted type lambdas, e.g.,
instance Functor (\a -> Either [a, b]) where ...

Perhaps we should instead use the more restrictive syntax, 
instance Functor (Either [_, b])

This would be too restrictive, e.g., if we have

class Functor (f : * -> *, c : * -> C) where
  map : c b => (a -> b # e) -> f a -> f b # e

instance Functor (\a -> Either [a, b], Trivial)

instance Functor (Set, Ord)

Closure guards


