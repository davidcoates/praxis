In order for read blocks to be safe, i.e. to guarantee the transient reference does not leave the read scope, it's going to be necessary to add a lifetime parameter to the reference type. Then the check simply becomes: is the lifetime parameter generated by the read present in the type of the return value?

To support this, reference operator (!) will need to be annotated with a lifetime parameter e.g. !v.

A type operator variable now also abstracts over lifetime. So ?v goes from meaning "either ! or id" to "either !v or id.

We'll also want to use !v (i.e. reference operator variable) as a type operator variable (when we don't want to allow the id case).

This will complicate the constraint solver which heavily reduces repeated type operator applications.



All in all the type of most functions shouldn't need to change. E.g. functor was...

interface Functor [?v, f] where
  map : forall ?v a b. (?v a -> b) -> ?v f a -> f b

and is still written the same, but now the meaning of ?v is expanded to include lifetimes.

