Variants and Records


type Maybe a = { Nothing () | Just a }

type Pair a b = { First a, Second b }
-- OR ?
type Pair (a,b) = { First a, Second b }

type List a = { Nil () | Cons { Head a, Tail List a } }
-- Right associative Tail List a = Tail (List a) ?

map f Nil () = Nil ()
map f 

type Vector a


-- possible?
type Vector' a
type Vector a = case a of Bool -> BitString
                          _    -> Vector' a



Streams

Annoying duplicaiton
Container c => Stream (Lens (c a) a)
               Stream (Lens (c a)! a!)

Lens Foo Bar
Lens Foo! Bar!

over :: Lens a b -> (b -> b) -> (a -> b) 

view :: Lens a b -> a -> b
or
view :: Lens a b -> a! -> b!

lens Foo, read only lens Foo! ?



Use ( , ) for records instead of { , }
( 1, 2, f = 3 ) is shorthand for ( first = 1, second = 2, f = 3 )
{ 1, 2, 3 } set literals
{ 1 : 2, 3 : 4, 5 : 6 } map literals (or if we want to use : for type of, then { 1 -> 2, 3 -> 4, 5 -> 6 }
{ ...  | ... } set comprehensions


( , ) don't implement Show, Ord etc themselves because arbitrary order would be confusiung
But data containing them can derive Show Ord etc, and it will be using the order as written in the data declaration

Lifting lenses (or just use newtype, which I think is fine)

'do', 'monad' blocks

All literals including [ ... ] and { ... } should be polymorphic.

Sequence ?
Array
Vector

Anonymous sum types?
( Left a | Right b )

Modules?
Nested modules?

data Either (a @ *, b @ *) = Left a | Right b


x.f shorthand for view f x ?



-- Records --
Record punning using @: { x, @from }

--- Constraint kind ---
Can mix types and constraints e.g., in type classes.
Call the combined form 'ctype'

--- Type and constraint synonyms ---
using <name> = <lambda ctype>
Can use fun lhs syntax.


--- Ctype records ---
Sometimes we want to treat a record type as a pattern, e.g., in data and class.
Do this using :, or @ if we want to leave the field name implicit.
class Functor (f @ * -> *, from : * -> Constraint) where
  ...

--- Type Classes ---

- Only one parameter (ctype)
- Instances allow lambda expression at the type level, however...
- No two instances for the same class can have the same head

We can, for example, define

instance Functor (\b -> Either (a,b)) where
  fmap f (Left a) = Left a
  fmap f (Right b) =  Right (f b)

But now we can't do instance Functor Either or instance Functor (\a -> Either (a,b)) etc.


The Set/Functor problem: Add constraint parameter

class Functor (f @ * -> *, from : * -> Constraint) where
  fmap :: forall a b. from a => (a -> b) -> f a -> f b

using EndoFunctor f = Functor (f, \a -> ())

instance Functor (Set, from = Ord) where
  ...


Unsolved problem:
When should we handle effects in classes?
E.g., should we allow fmap to be effectful?

class Functor (f @ T -> T, from : T -> C) where
  fmap :: forall (a : T) (b : T) (e : E). from a => (a -> b # e) -> f a -> f b # e


Should we allow impure types in type classes? data? I don't see why not. Although most of the time e.g., if it is the arg of a function it won't be allowed due to kinding error.

data Fun (a @ P, b @ I) = Fun (a -> b)

using P = Pure
using I = Impure
using C = Constraint
using E = Effect


Implicit conversion rules:

     t : Pure
--------------------
 t # Pure : Impure


  t # e : Impure
     e ~ Pure
------------------
     t : Pure


"record value"
"record type"

"pure type record" (in type construtors e.g., data Either (a, b) )
"universal record" (in instances)

head (C t : Pure)      = Just "C"
head (t # e : Impure)  = Just (head t)
head (_ : Constraint)  = Nothing
head (_ : Effect)      = Nothing

head <pure type record> = record of heads
head <universal record> = record of heads

Functional dependencies




Don't allow impure type variables.

Data parameter can be a REP (Record, Effect, Pure) ... or maybe we allow FREP ? (Function (i.e., higher order), Record, Effect, Pure)

Class: REPC, FREPC?

